// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: proposed_plugins.sql

package queries

import (
	"context"
)

const createProposedPlugin = `-- name: CreateProposedPlugin :one

INSERT INTO proposed_plugins (public_key, plugin_id, title, description, server_endpoint, category)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING public_key, plugin_id, title, description, server_endpoint, category, status, created_at, updated_at
`

type CreateProposedPluginParams struct {
	PublicKey      string         `json:"public_key"`
	PluginID       string         `json:"plugin_id"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	ServerEndpoint string         `json:"server_endpoint"`
	Category       PluginCategory `json:"category"`
}

// Proposed plugins table queries
func (q *Queries) CreateProposedPlugin(ctx context.Context, arg *CreateProposedPluginParams) (*ProposedPlugin, error) {
	row := q.db.QueryRow(ctx, createProposedPlugin,
		arg.PublicKey,
		arg.PluginID,
		arg.Title,
		arg.Description,
		arg.ServerEndpoint,
		arg.Category,
	)
	var i ProposedPlugin
	err := row.Scan(
		&i.PublicKey,
		&i.PluginID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProposedPlugin = `-- name: GetProposedPlugin :one
SELECT public_key, plugin_id, title, description, server_endpoint, category, status, created_at, updated_at FROM proposed_plugins
WHERE public_key = $1 AND plugin_id = $2
`

type GetProposedPluginParams struct {
	PublicKey string `json:"public_key"`
	PluginID  string `json:"plugin_id"`
}

func (q *Queries) GetProposedPlugin(ctx context.Context, arg *GetProposedPluginParams) (*ProposedPlugin, error) {
	row := q.db.QueryRow(ctx, getProposedPlugin, arg.PublicKey, arg.PluginID)
	var i ProposedPlugin
	err := row.Scan(
		&i.PublicKey,
		&i.PluginID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProposedPluginsByPublicKey = `-- name: GetProposedPluginsByPublicKey :many
SELECT public_key, plugin_id, title, description, server_endpoint, category, status, created_at, updated_at FROM proposed_plugins
WHERE public_key = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProposedPluginsByPublicKey(ctx context.Context, publicKey string) ([]*ProposedPlugin, error) {
	rows, err := q.db.Query(ctx, getProposedPluginsByPublicKey, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProposedPlugin{}
	for rows.Next() {
		var i ProposedPlugin
		if err := rows.Scan(
			&i.PublicKey,
			&i.PluginID,
			&i.Title,
			&i.Description,
			&i.ServerEndpoint,
			&i.Category,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProposedPluginStatus = `-- name: UpdateProposedPluginStatus :one
UPDATE proposed_plugins
SET status = $1, updated_at = NOW()
WHERE public_key = $2 AND plugin_id = $3 AND status = $4
RETURNING public_key, plugin_id, title, description, server_endpoint, category, status, created_at, updated_at
`

type UpdateProposedPluginStatusParams struct {
	NewStatus     ProposedPluginStatus `json:"new_status"`
	PublicKey     string               `json:"public_key"`
	PluginID      string               `json:"plugin_id"`
	CurrentStatus ProposedPluginStatus `json:"current_status"`
}

func (q *Queries) UpdateProposedPluginStatus(ctx context.Context, arg *UpdateProposedPluginStatusParams) (*ProposedPlugin, error) {
	row := q.db.QueryRow(ctx, updateProposedPluginStatus,
		arg.NewStatus,
		arg.PublicKey,
		arg.PluginID,
		arg.CurrentStatus,
	)
	var i ProposedPlugin
	err := row.Scan(
		&i.PublicKey,
		&i.PluginID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
