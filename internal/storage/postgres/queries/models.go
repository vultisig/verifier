// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package queries

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchStatus string

const (
	BatchStatusSIGNED    BatchStatus = "SIGNED"
	BatchStatusBATCHED   BatchStatus = "BATCHED"
	BatchStatusFAILED    BatchStatus = "FAILED"
	BatchStatusCOMPLETED BatchStatus = "COMPLETED"
)

func (e *BatchStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BatchStatus(s)
	case string:
		*e = BatchStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BatchStatus: %T", src)
	}
	return nil
}

type NullBatchStatus struct {
	BatchStatus BatchStatus `json:"batch_status"`
	Valid       bool        `json:"valid"` // Valid is true if BatchStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBatchStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BatchStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BatchStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBatchStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BatchStatus), nil
}

type BillingAsset string

const (
	BillingAssetUsdc BillingAsset = "usdc"
)

func (e *BillingAsset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingAsset(s)
	case string:
		*e = BillingAsset(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingAsset: %T", src)
	}
	return nil
}

type NullBillingAsset struct {
	BillingAsset BillingAsset `json:"billing_asset"`
	Valid        bool         `json:"valid"` // Valid is true if BillingAsset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingAsset) Scan(value interface{}) error {
	if value == nil {
		ns.BillingAsset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingAsset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingAsset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingAsset), nil
}

type PluginCategory string

const (
	PluginCategoryAiAgent PluginCategory = "ai-agent"
	PluginCategoryPlugin  PluginCategory = "plugin"
	PluginCategoryApp     PluginCategory = "app"
)

func (e *PluginCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginCategory(s)
	case string:
		*e = PluginCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginCategory: %T", src)
	}
	return nil
}

type NullPluginCategory struct {
	PluginCategory PluginCategory `json:"plugin_category"`
	Valid          bool           `json:"valid"` // Valid is true if PluginCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginCategory) Scan(value interface{}) error {
	if value == nil {
		ns.PluginCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginCategory), nil
}

type PluginID string

const (
	PluginIDVultisigDca0000            PluginID = "vultisig-dca-0000"
	PluginIDVultisigPayroll0000        PluginID = "vultisig-payroll-0000"
	PluginIDVultisigFeesFeee           PluginID = "vultisig-fees-feee"
	PluginIDVultisigCopytrader0000     PluginID = "vultisig-copytrader-0000"
	PluginIDNbitsLabsMerkleE93d        PluginID = "nbits-labs-merkle-e93d"
	PluginIDVultisigRecurringSends0000 PluginID = "vultisig-recurring-sends-0000"
)

func (e *PluginID) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginID(s)
	case string:
		*e = PluginID(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginID: %T", src)
	}
	return nil
}

type NullPluginID struct {
	PluginID PluginID `json:"plugin_id"`
	Valid    bool     `json:"valid"` // Valid is true if PluginID is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginID) Scan(value interface{}) error {
	if value == nil {
		ns.PluginID, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginID.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginID) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginID), nil
}

type PluginOwnerAddedVia string

const (
	PluginOwnerAddedViaBootstrapPluginKey PluginOwnerAddedVia = "bootstrap_plugin_key"
	PluginOwnerAddedViaOwnerApi           PluginOwnerAddedVia = "owner_api"
	PluginOwnerAddedViaAdminCli           PluginOwnerAddedVia = "admin_cli"
)

func (e *PluginOwnerAddedVia) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginOwnerAddedVia(s)
	case string:
		*e = PluginOwnerAddedVia(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginOwnerAddedVia: %T", src)
	}
	return nil
}

type NullPluginOwnerAddedVia struct {
	PluginOwnerAddedVia PluginOwnerAddedVia `json:"plugin_owner_added_via"`
	Valid               bool                `json:"valid"` // Valid is true if PluginOwnerAddedVia is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginOwnerAddedVia) Scan(value interface{}) error {
	if value == nil {
		ns.PluginOwnerAddedVia, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginOwnerAddedVia.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginOwnerAddedVia) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginOwnerAddedVia), nil
}

type PluginOwnerRole string

const (
	PluginOwnerRoleAdmin PluginOwnerRole = "admin"
)

func (e *PluginOwnerRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginOwnerRole(s)
	case string:
		*e = PluginOwnerRole(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginOwnerRole: %T", src)
	}
	return nil
}

type NullPluginOwnerRole struct {
	PluginOwnerRole PluginOwnerRole `json:"plugin_owner_role"`
	Valid           bool            `json:"valid"` // Valid is true if PluginOwnerRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginOwnerRole) Scan(value interface{}) error {
	if value == nil {
		ns.PluginOwnerRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginOwnerRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginOwnerRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginOwnerRole), nil
}

type PricingAsset string

const (
	PricingAssetUsdc PricingAsset = "usdc"
)

func (e *PricingAsset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingAsset(s)
	case string:
		*e = PricingAsset(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingAsset: %T", src)
	}
	return nil
}

type NullPricingAsset struct {
	PricingAsset PricingAsset `json:"pricing_asset"`
	Valid        bool         `json:"valid"` // Valid is true if PricingAsset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingAsset) Scan(value interface{}) error {
	if value == nil {
		ns.PricingAsset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingAsset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingAsset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingAsset), nil
}

type PricingFrequency string

const (
	PricingFrequencyDaily    PricingFrequency = "daily"
	PricingFrequencyWeekly   PricingFrequency = "weekly"
	PricingFrequencyBiweekly PricingFrequency = "biweekly"
	PricingFrequencyMonthly  PricingFrequency = "monthly"
)

func (e *PricingFrequency) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingFrequency(s)
	case string:
		*e = PricingFrequency(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingFrequency: %T", src)
	}
	return nil
}

type NullPricingFrequency struct {
	PricingFrequency PricingFrequency `json:"pricing_frequency"`
	Valid            bool             `json:"valid"` // Valid is true if PricingFrequency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingFrequency) Scan(value interface{}) error {
	if value == nil {
		ns.PricingFrequency, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingFrequency.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingFrequency) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingFrequency), nil
}

type PricingMetric string

const (
	PricingMetricFixed PricingMetric = "fixed"
)

func (e *PricingMetric) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingMetric(s)
	case string:
		*e = PricingMetric(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingMetric: %T", src)
	}
	return nil
}

type NullPricingMetric struct {
	PricingMetric PricingMetric `json:"pricing_metric"`
	Valid         bool          `json:"valid"` // Valid is true if PricingMetric is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingMetric) Scan(value interface{}) error {
	if value == nil {
		ns.PricingMetric, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingMetric.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingMetric) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingMetric), nil
}

type PricingType string

const (
	PricingTypeOnce      PricingType = "once"
	PricingTypeRecurring PricingType = "recurring"
	PricingTypePerTx     PricingType = "per-tx"
)

func (e *PricingType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingType(s)
	case string:
		*e = PricingType(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingType: %T", src)
	}
	return nil
}

type NullPricingType struct {
	PricingType PricingType `json:"pricing_type"`
	Valid       bool        `json:"valid"` // Valid is true if PricingType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingType) Scan(value interface{}) error {
	if value == nil {
		ns.PricingType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingType), nil
}

type TransactionType string

const (
	TransactionTypeDebit  TransactionType = "debit"
	TransactionTypeCredit TransactionType = "credit"
)

func (e *TransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionType(s)
	case string:
		*e = TransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionType: %T", src)
	}
	return nil
}

type NullTransactionType struct {
	TransactionType TransactionType `json:"transaction_type"`
	Valid           bool            `json:"valid"` // Valid is true if TransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionType), nil
}

type TxIndexerStatus string

const (
	TxIndexerStatusPROPOSED TxIndexerStatus = "PROPOSED"
	TxIndexerStatusVERIFIED TxIndexerStatus = "VERIFIED"
	TxIndexerStatusSIGNED   TxIndexerStatus = "SIGNED"
)

func (e *TxIndexerStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxIndexerStatus(s)
	case string:
		*e = TxIndexerStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TxIndexerStatus: %T", src)
	}
	return nil
}

type NullTxIndexerStatus struct {
	TxIndexerStatus TxIndexerStatus `json:"tx_indexer_status"`
	Valid           bool            `json:"valid"` // Valid is true if TxIndexerStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxIndexerStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TxIndexerStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxIndexerStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxIndexerStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxIndexerStatus), nil
}

type TxIndexerStatusOnchain string

const (
	TxIndexerStatusOnchainPENDING TxIndexerStatusOnchain = "PENDING"
	TxIndexerStatusOnchainSUCCESS TxIndexerStatusOnchain = "SUCCESS"
	TxIndexerStatusOnchainFAIL    TxIndexerStatusOnchain = "FAIL"
)

func (e *TxIndexerStatusOnchain) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxIndexerStatusOnchain(s)
	case string:
		*e = TxIndexerStatusOnchain(s)
	default:
		return fmt.Errorf("unsupported scan type for TxIndexerStatusOnchain: %T", src)
	}
	return nil
}

type NullTxIndexerStatusOnchain struct {
	TxIndexerStatusOnchain TxIndexerStatusOnchain `json:"tx_indexer_status_onchain"`
	Valid                  bool                   `json:"valid"` // Valid is true if TxIndexerStatusOnchain is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxIndexerStatusOnchain) Scan(value interface{}) error {
	if value == nil {
		ns.TxIndexerStatusOnchain, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxIndexerStatusOnchain.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxIndexerStatusOnchain) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxIndexerStatusOnchain), nil
}

type ControlFlag struct {
	Key       string             `json:"key"`
	Enabled   bool               `json:"enabled"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Fee struct {
	ID              int64              `json:"id"`
	PolicyID        pgtype.UUID        `json:"policy_id"`
	PublicKey       string             `json:"public_key"`
	TransactionType TransactionType    `json:"transaction_type"`
	Amount          int64              `json:"amount"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FeeType         string             `json:"fee_type"`
	Metadata        []byte             `json:"metadata"`
	UnderlyingType  string             `json:"underlying_type"`
	UnderlyingID    string             `json:"underlying_id"`
	PluginID        pgtype.Text        `json:"plugin_id"`
}

type FeeBatch struct {
	ID             int64              `json:"id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	TotalValue     int64              `json:"total_value"`
	Status         BatchStatus        `json:"status"`
	BatchCutoff    int32              `json:"batch_cutoff"`
	CollectionTxID pgtype.Text        `json:"collection_tx_id"`
}

type FeeBatchMember struct {
	BatchID int64 `json:"batch_id"`
	FeeID   int64 `json:"fee_id"`
}

type Plugin struct {
	ID             PluginID           `json:"id"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	ServerEndpoint string             `json:"server_endpoint"`
	Category       PluginCategory     `json:"category"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	LogoUrl        string             `json:"logo_url"`
	ThumbnailUrl   string             `json:"thumbnail_url"`
	Images         []byte             `json:"images"`
	Faqs           []byte             `json:"faqs"`
	Features       []byte             `json:"features"`
	Audited        bool               `json:"audited"`
}

type PluginApikey struct {
	ID        pgtype.UUID        `json:"id"`
	PluginID  PluginID           `json:"plugin_id"`
	Apikey    string             `json:"apikey"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Status    int32              `json:"status"`
}

type PluginInstallation struct {
	PluginID    PluginID           `json:"plugin_id"`
	PublicKey   string             `json:"public_key"`
	InstalledAt pgtype.Timestamptz `json:"installed_at"`
}

type PluginOwner struct {
	PluginID         PluginID            `json:"plugin_id"`
	PublicKey        string              `json:"public_key"`
	Active           bool                `json:"active"`
	Role             PluginOwnerRole     `json:"role"`
	AddedVia         PluginOwnerAddedVia `json:"added_via"`
	AddedByPublicKey pgtype.Text         `json:"added_by_public_key"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
}

type PluginPauseHistory struct {
	ID                pgtype.UUID        `json:"id"`
	PluginID          PluginID           `json:"plugin_id"`
	Action            string             `json:"action"`
	ReportCountWindow pgtype.Int4        `json:"report_count_window"`
	ActiveUsers       pgtype.Int4        `json:"active_users"`
	ThresholdRate     pgtype.Numeric     `json:"threshold_rate"`
	Reason            pgtype.Text        `json:"reason"`
	TriggeredBy       pgtype.Text        `json:"triggered_by"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

type PluginPolicy struct {
	ID                 pgtype.UUID        `json:"id"`
	PublicKey          string             `json:"public_key"`
	PluginID           PluginID           `json:"plugin_id"`
	PluginVersion      string             `json:"plugin_version"`
	PolicyVersion      int32              `json:"policy_version"`
	Signature          string             `json:"signature"`
	Recipe             string             `json:"recipe"`
	Active             bool               `json:"active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Deleted            bool               `json:"deleted"`
	DeactivationReason pgtype.Text        `json:"deactivation_reason"`
}

type PluginPolicyBilling struct {
	ID             pgtype.UUID          `json:"id"`
	Type           PricingType          `json:"type"`
	Frequency      NullPricingFrequency `json:"frequency"`
	StartDate      pgtype.Date          `json:"start_date"`
	Amount         int64                `json:"amount"`
	Asset          PricingAsset         `json:"asset"`
	PluginPolicyID pgtype.UUID          `json:"plugin_policy_id"`
}

type PluginPolicySync struct {
	ID        pgtype.UUID        `json:"id"`
	PolicyID  pgtype.UUID        `json:"policy_id"`
	PluginID  PluginID           `json:"plugin_id"`
	SyncType  int32              `json:"sync_type"`
	Signature pgtype.Text        `json:"signature"`
	Status    int32              `json:"status"`
	Reason    pgtype.Text        `json:"reason"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type PluginRating struct {
	PluginID     PluginID           `json:"plugin_id"`
	AvgRating    pgtype.Numeric     `json:"avg_rating"`
	TotalRatings int32              `json:"total_ratings"`
	Rating1Count int32              `json:"rating_1_count"`
	Rating2Count int32              `json:"rating_2_count"`
	Rating3Count int32              `json:"rating_3_count"`
	Rating4Count int32              `json:"rating_4_count"`
	Rating5Count int32              `json:"rating_5_count"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type PluginReport struct {
	PluginID          PluginID           `json:"plugin_id"`
	ReporterPublicKey string             `json:"reporter_public_key"`
	Reason            string             `json:"reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastReportedAt    pgtype.Timestamptz `json:"last_reported_at"`
	ReportCount       int32              `json:"report_count"`
	Details           string             `json:"details"`
}

type PluginTag struct {
	PluginID PluginID    `json:"plugin_id"`
	TagID    pgtype.UUID `json:"tag_id"`
}

type Pricing struct {
	ID        pgtype.UUID          `json:"id"`
	Type      PricingType          `json:"type"`
	Frequency NullPricingFrequency `json:"frequency"`
	Amount    int64                `json:"amount"`
	Asset     PricingAsset         `json:"asset"`
	Metric    PricingMetric        `json:"metric"`
	PluginID  PluginID             `json:"plugin_id"`
	CreatedAt pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt pgtype.Timestamptz   `json:"updated_at"`
}

type Review struct {
	ID        pgtype.UUID        `json:"id"`
	PluginID  NullPluginID       `json:"plugin_id"`
	PublicKey string             `json:"public_key"`
	Rating    int32              `json:"rating"`
	Comment   pgtype.Text        `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Tag struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type TxIndexer struct {
	ID            pgtype.UUID                `json:"id"`
	PluginID      string                     `json:"plugin_id"`
	TxHash        pgtype.Text                `json:"tx_hash"`
	ChainID       int32                      `json:"chain_id"`
	PolicyID      pgtype.UUID                `json:"policy_id"`
	TokenID       string                     `json:"token_id"`
	FromPublicKey string                     `json:"from_public_key"`
	ToPublicKey   string                     `json:"to_public_key"`
	ProposedTxHex string                     `json:"proposed_tx_hex"`
	Status        TxIndexerStatus            `json:"status"`
	StatusOnchain NullTxIndexerStatusOnchain `json:"status_onchain"`
	Lost          bool                       `json:"lost"`
	BroadcastedAt pgtype.Timestamp           `json:"broadcasted_at"`
	CreatedAt     pgtype.Timestamp           `json:"created_at"`
	UpdatedAt     pgtype.Timestamp           `json:"updated_at"`
	Amount        pgtype.Text                `json:"amount"`
}

type VaultToken struct {
	ID         pgtype.UUID        `json:"id"`
	TokenID    string             `json:"token_id"`
	PublicKey  string             `json:"public_key"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	RevokedAt  pgtype.Timestamptz `json:"revoked_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}
