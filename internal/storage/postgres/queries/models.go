// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package queries

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchStatus string

const (
	BatchStatusSIGNED    BatchStatus = "SIGNED"
	BatchStatusBATCHED   BatchStatus = "BATCHED"
	BatchStatusFAILED    BatchStatus = "FAILED"
	BatchStatusCOMPLETED BatchStatus = "COMPLETED"
)

func (e *BatchStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BatchStatus(s)
	case string:
		*e = BatchStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BatchStatus: %T", src)
	}
	return nil
}

type NullBatchStatus struct {
	BatchStatus BatchStatus `json:"batch_status"`
	Valid       bool        `json:"valid"` // Valid is true if BatchStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBatchStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BatchStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BatchStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBatchStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BatchStatus), nil
}

type BillingAsset string

const (
	BillingAssetUsdc BillingAsset = "usdc"
)

func (e *BillingAsset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingAsset(s)
	case string:
		*e = BillingAsset(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingAsset: %T", src)
	}
	return nil
}

type NullBillingAsset struct {
	BillingAsset BillingAsset `json:"billing_asset"`
	Valid        bool         `json:"valid"` // Valid is true if BillingAsset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingAsset) Scan(value interface{}) error {
	if value == nil {
		ns.BillingAsset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingAsset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingAsset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingAsset), nil
}

type PluginCategory string

const (
	PluginCategoryAiAgent PluginCategory = "ai-agent"
	PluginCategoryPlugin  PluginCategory = "plugin"
	PluginCategoryApp     PluginCategory = "app"
)

func (e *PluginCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginCategory(s)
	case string:
		*e = PluginCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginCategory: %T", src)
	}
	return nil
}

type NullPluginCategory struct {
	PluginCategory PluginCategory `json:"plugin_category"`
	Valid          bool           `json:"valid"` // Valid is true if PluginCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginCategory) Scan(value interface{}) error {
	if value == nil {
		ns.PluginCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginCategory), nil
}

type PluginOwnerAddedVia string

const (
	PluginOwnerAddedViaBootstrapPluginKey PluginOwnerAddedVia = "bootstrap_plugin_key"
	PluginOwnerAddedViaOwnerApi           PluginOwnerAddedVia = "owner_api"
	PluginOwnerAddedViaAdminCli           PluginOwnerAddedVia = "admin_cli"
	PluginOwnerAddedViaMagicLink          PluginOwnerAddedVia = "magic_link"
	PluginOwnerAddedViaPortalCreate       PluginOwnerAddedVia = "portal_create"
)

func (e *PluginOwnerAddedVia) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginOwnerAddedVia(s)
	case string:
		*e = PluginOwnerAddedVia(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginOwnerAddedVia: %T", src)
	}
	return nil
}

type NullPluginOwnerAddedVia struct {
	PluginOwnerAddedVia PluginOwnerAddedVia `json:"plugin_owner_added_via"`
	Valid               bool                `json:"valid"` // Valid is true if PluginOwnerAddedVia is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginOwnerAddedVia) Scan(value interface{}) error {
	if value == nil {
		ns.PluginOwnerAddedVia, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginOwnerAddedVia.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginOwnerAddedVia) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginOwnerAddedVia), nil
}

type PluginOwnerRole string

const (
	PluginOwnerRoleAdmin  PluginOwnerRole = "admin"
	PluginOwnerRoleStaff  PluginOwnerRole = "staff"
	PluginOwnerRoleEditor PluginOwnerRole = "editor"
	PluginOwnerRoleViewer PluginOwnerRole = "viewer"
)

func (e *PluginOwnerRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginOwnerRole(s)
	case string:
		*e = PluginOwnerRole(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginOwnerRole: %T", src)
	}
	return nil
}

type NullPluginOwnerRole struct {
	PluginOwnerRole PluginOwnerRole `json:"plugin_owner_role"`
	Valid           bool            `json:"valid"` // Valid is true if PluginOwnerRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginOwnerRole) Scan(value interface{}) error {
	if value == nil {
		ns.PluginOwnerRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginOwnerRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginOwnerRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginOwnerRole), nil
}

type PortalApproverAddedVia string

const (
	PortalApproverAddedViaBootstrap   PortalApproverAddedVia = "bootstrap"
	PortalApproverAddedViaAdminPortal PortalApproverAddedVia = "admin_portal"
	PortalApproverAddedViaCli         PortalApproverAddedVia = "cli"
)

func (e *PortalApproverAddedVia) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PortalApproverAddedVia(s)
	case string:
		*e = PortalApproverAddedVia(s)
	default:
		return fmt.Errorf("unsupported scan type for PortalApproverAddedVia: %T", src)
	}
	return nil
}

type NullPortalApproverAddedVia struct {
	PortalApproverAddedVia PortalApproverAddedVia `json:"portal_approver_added_via"`
	Valid                  bool                   `json:"valid"` // Valid is true if PortalApproverAddedVia is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPortalApproverAddedVia) Scan(value interface{}) error {
	if value == nil {
		ns.PortalApproverAddedVia, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PortalApproverAddedVia.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPortalApproverAddedVia) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PortalApproverAddedVia), nil
}

type PricingAsset string

const (
	PricingAssetUsdc PricingAsset = "usdc"
)

func (e *PricingAsset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingAsset(s)
	case string:
		*e = PricingAsset(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingAsset: %T", src)
	}
	return nil
}

type NullPricingAsset struct {
	PricingAsset PricingAsset `json:"pricing_asset"`
	Valid        bool         `json:"valid"` // Valid is true if PricingAsset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingAsset) Scan(value interface{}) error {
	if value == nil {
		ns.PricingAsset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingAsset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingAsset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingAsset), nil
}

type PricingFrequency string

const (
	PricingFrequencyDaily    PricingFrequency = "daily"
	PricingFrequencyWeekly   PricingFrequency = "weekly"
	PricingFrequencyBiweekly PricingFrequency = "biweekly"
	PricingFrequencyMonthly  PricingFrequency = "monthly"
)

func (e *PricingFrequency) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingFrequency(s)
	case string:
		*e = PricingFrequency(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingFrequency: %T", src)
	}
	return nil
}

type NullPricingFrequency struct {
	PricingFrequency PricingFrequency `json:"pricing_frequency"`
	Valid            bool             `json:"valid"` // Valid is true if PricingFrequency is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingFrequency) Scan(value interface{}) error {
	if value == nil {
		ns.PricingFrequency, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingFrequency.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingFrequency) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingFrequency), nil
}

type PricingMetric string

const (
	PricingMetricFixed PricingMetric = "fixed"
)

func (e *PricingMetric) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingMetric(s)
	case string:
		*e = PricingMetric(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingMetric: %T", src)
	}
	return nil
}

type NullPricingMetric struct {
	PricingMetric PricingMetric `json:"pricing_metric"`
	Valid         bool          `json:"valid"` // Valid is true if PricingMetric is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingMetric) Scan(value interface{}) error {
	if value == nil {
		ns.PricingMetric, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingMetric.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingMetric) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingMetric), nil
}

type PricingType string

const (
	PricingTypeOnce      PricingType = "once"
	PricingTypeRecurring PricingType = "recurring"
	PricingTypePerTx     PricingType = "per-tx"
)

func (e *PricingType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingType(s)
	case string:
		*e = PricingType(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingType: %T", src)
	}
	return nil
}

type NullPricingType struct {
	PricingType PricingType `json:"pricing_type"`
	Valid       bool        `json:"valid"` // Valid is true if PricingType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingType) Scan(value interface{}) error {
	if value == nil {
		ns.PricingType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingType), nil
}

type ProposedPluginPricing string

const (
	ProposedPluginPricingFree       ProposedPluginPricing = "free"
	ProposedPluginPricingPerTx      ProposedPluginPricing = "per-tx"
	ProposedPluginPricingPerInstall ProposedPluginPricing = "per-install"
)

func (e *ProposedPluginPricing) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProposedPluginPricing(s)
	case string:
		*e = ProposedPluginPricing(s)
	default:
		return fmt.Errorf("unsupported scan type for ProposedPluginPricing: %T", src)
	}
	return nil
}

type NullProposedPluginPricing struct {
	ProposedPluginPricing ProposedPluginPricing `json:"proposed_plugin_pricing"`
	Valid                 bool                  `json:"valid"` // Valid is true if ProposedPluginPricing is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProposedPluginPricing) Scan(value interface{}) error {
	if value == nil {
		ns.ProposedPluginPricing, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProposedPluginPricing.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProposedPluginPricing) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProposedPluginPricing), nil
}

type ProposedPluginStatus string

const (
	ProposedPluginStatusSubmitted ProposedPluginStatus = "submitted"
	ProposedPluginStatusApproved  ProposedPluginStatus = "approved"
	ProposedPluginStatusListed    ProposedPluginStatus = "listed"
	ProposedPluginStatusArchived  ProposedPluginStatus = "archived"
)

func (e *ProposedPluginStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProposedPluginStatus(s)
	case string:
		*e = ProposedPluginStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProposedPluginStatus: %T", src)
	}
	return nil
}

type NullProposedPluginStatus struct {
	ProposedPluginStatus ProposedPluginStatus `json:"proposed_plugin_status"`
	Valid                bool                 `json:"valid"` // Valid is true if ProposedPluginStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProposedPluginStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProposedPluginStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProposedPluginStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProposedPluginStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProposedPluginStatus), nil
}

type TransactionType string

const (
	TransactionTypeDebit  TransactionType = "debit"
	TransactionTypeCredit TransactionType = "credit"
)

func (e *TransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionType(s)
	case string:
		*e = TransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionType: %T", src)
	}
	return nil
}

type NullTransactionType struct {
	TransactionType TransactionType `json:"transaction_type"`
	Valid           bool            `json:"valid"` // Valid is true if TransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionType), nil
}

type TxIndexerStatus string

const (
	TxIndexerStatusPROPOSED TxIndexerStatus = "PROPOSED"
	TxIndexerStatusVERIFIED TxIndexerStatus = "VERIFIED"
	TxIndexerStatusSIGNED   TxIndexerStatus = "SIGNED"
)

func (e *TxIndexerStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxIndexerStatus(s)
	case string:
		*e = TxIndexerStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TxIndexerStatus: %T", src)
	}
	return nil
}

type NullTxIndexerStatus struct {
	TxIndexerStatus TxIndexerStatus `json:"tx_indexer_status"`
	Valid           bool            `json:"valid"` // Valid is true if TxIndexerStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxIndexerStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TxIndexerStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxIndexerStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxIndexerStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxIndexerStatus), nil
}

type TxIndexerStatusOnchain string

const (
	TxIndexerStatusOnchainPENDING TxIndexerStatusOnchain = "PENDING"
	TxIndexerStatusOnchainSUCCESS TxIndexerStatusOnchain = "SUCCESS"
	TxIndexerStatusOnchainFAIL    TxIndexerStatusOnchain = "FAIL"
)

func (e *TxIndexerStatusOnchain) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxIndexerStatusOnchain(s)
	case string:
		*e = TxIndexerStatusOnchain(s)
	default:
		return fmt.Errorf("unsupported scan type for TxIndexerStatusOnchain: %T", src)
	}
	return nil
}

type NullTxIndexerStatusOnchain struct {
	TxIndexerStatusOnchain TxIndexerStatusOnchain `json:"tx_indexer_status_onchain"`
	Valid                  bool                   `json:"valid"` // Valid is true if TxIndexerStatusOnchain is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxIndexerStatusOnchain) Scan(value interface{}) error {
	if value == nil {
		ns.TxIndexerStatusOnchain, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxIndexerStatusOnchain.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxIndexerStatusOnchain) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxIndexerStatusOnchain), nil
}

type ControlFlag struct {
	Key       string             `json:"key"`
	Enabled   bool               `json:"enabled"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Fee struct {
	ID              int64              `json:"id"`
	PolicyID        pgtype.UUID        `json:"policy_id"`
	PublicKey       string             `json:"public_key"`
	TransactionType TransactionType    `json:"transaction_type"`
	Amount          int64              `json:"amount"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FeeType         string             `json:"fee_type"`
	Metadata        []byte             `json:"metadata"`
	UnderlyingType  string             `json:"underlying_type"`
	UnderlyingID    string             `json:"underlying_id"`
	PluginID        pgtype.Text        `json:"plugin_id"`
}

type FeeBatch struct {
	ID             int64              `json:"id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	TotalValue     int64              `json:"total_value"`
	Status         BatchStatus        `json:"status"`
	BatchCutoff    int32              `json:"batch_cutoff"`
	CollectionTxID pgtype.Text        `json:"collection_tx_id"`
}

type FeeBatchMember struct {
	BatchID int64 `json:"batch_id"`
	FeeID   int64 `json:"fee_id"`
}

type Plugin struct {
	ID             string             `json:"id"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	ServerEndpoint string             `json:"server_endpoint"`
	Category       PluginCategory     `json:"category"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Faqs           []byte             `json:"faqs"`
	Features       []byte             `json:"features"`
	Audited        bool               `json:"audited"`
}

type PluginApikey struct {
	ID        pgtype.UUID        `json:"id"`
	PluginID  string             `json:"plugin_id"`
	Apikey    string             `json:"apikey"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Status    int32              `json:"status"`
}

type PluginImage struct {
	ID                  pgtype.UUID        `json:"id"`
	PluginID            string             `json:"plugin_id"`
	ImageType           string             `json:"image_type"`
	S3Path              string             `json:"s3_path"`
	ImageOrder          int32              `json:"image_order"`
	UploadedByPublicKey string             `json:"uploaded_by_public_key"`
	Visible             bool               `json:"visible"`
	Deleted             bool               `json:"deleted"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ContentType         string             `json:"content_type"`
	Filename            string             `json:"filename"`
}

type PluginInstallation struct {
	PluginID    string             `json:"plugin_id"`
	PublicKey   string             `json:"public_key"`
	InstalledAt pgtype.Timestamptz `json:"installed_at"`
}

type PluginOwner struct {
	PluginID         string              `json:"plugin_id"`
	PublicKey        string              `json:"public_key"`
	Active           bool                `json:"active"`
	Role             PluginOwnerRole     `json:"role"`
	AddedVia         PluginOwnerAddedVia `json:"added_via"`
	AddedByPublicKey pgtype.Text         `json:"added_by_public_key"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
	LinkID           pgtype.UUID         `json:"link_id"`
}

type PluginPauseHistory struct {
	ID                pgtype.UUID        `json:"id"`
	PluginID          string             `json:"plugin_id"`
	Action            string             `json:"action"`
	ReportCountWindow pgtype.Int4        `json:"report_count_window"`
	ActiveUsers       pgtype.Int4        `json:"active_users"`
	ThresholdRate     pgtype.Numeric     `json:"threshold_rate"`
	Reason            pgtype.Text        `json:"reason"`
	TriggeredBy       pgtype.Text        `json:"triggered_by"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

type PluginPolicy struct {
	ID                 pgtype.UUID        `json:"id"`
	PublicKey          string             `json:"public_key"`
	PluginID           string             `json:"plugin_id"`
	PluginVersion      string             `json:"plugin_version"`
	PolicyVersion      int32              `json:"policy_version"`
	Signature          string             `json:"signature"`
	Recipe             string             `json:"recipe"`
	Active             bool               `json:"active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Deleted            bool               `json:"deleted"`
	DeactivationReason pgtype.Text        `json:"deactivation_reason"`
}

type PluginPolicyBilling struct {
	ID             pgtype.UUID          `json:"id"`
	Type           PricingType          `json:"type"`
	Frequency      NullPricingFrequency `json:"frequency"`
	StartDate      pgtype.Date          `json:"start_date"`
	Amount         int64                `json:"amount"`
	Asset          PricingAsset         `json:"asset"`
	PluginPolicyID pgtype.UUID          `json:"plugin_policy_id"`
}

type PluginPolicySync struct {
	ID        pgtype.UUID        `json:"id"`
	PolicyID  pgtype.UUID        `json:"policy_id"`
	PluginID  string             `json:"plugin_id"`
	SyncType  int32              `json:"sync_type"`
	Signature pgtype.Text        `json:"signature"`
	Status    int32              `json:"status"`
	Reason    pgtype.Text        `json:"reason"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type PluginRating struct {
	PluginID     string             `json:"plugin_id"`
	AvgRating    pgtype.Numeric     `json:"avg_rating"`
	TotalRatings int32              `json:"total_ratings"`
	Rating1Count int32              `json:"rating_1_count"`
	Rating2Count int32              `json:"rating_2_count"`
	Rating3Count int32              `json:"rating_3_count"`
	Rating4Count int32              `json:"rating_4_count"`
	Rating5Count int32              `json:"rating_5_count"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type PluginReport struct {
	PluginID          string             `json:"plugin_id"`
	ReporterPublicKey string             `json:"reporter_public_key"`
	Reason            string             `json:"reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	LastReportedAt    pgtype.Timestamptz `json:"last_reported_at"`
	ReportCount       int32              `json:"report_count"`
	Details           string             `json:"details"`
}

type PluginTag struct {
	PluginID string      `json:"plugin_id"`
	TagID    pgtype.UUID `json:"tag_id"`
}

type PortalApprover struct {
	PublicKey        string                 `json:"public_key"`
	Active           bool                   `json:"active"`
	AddedVia         PortalApproverAddedVia `json:"added_via"`
	AddedByPublicKey pgtype.Text            `json:"added_by_public_key"`
	CreatedAt        pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz     `json:"updated_at"`
}

type Pricing struct {
	ID        pgtype.UUID          `json:"id"`
	Type      PricingType          `json:"type"`
	Frequency NullPricingFrequency `json:"frequency"`
	Amount    int64                `json:"amount"`
	Asset     PricingAsset         `json:"asset"`
	Metric    PricingMetric        `json:"metric"`
	PluginID  string               `json:"plugin_id"`
	CreatedAt pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt pgtype.Timestamptz   `json:"updated_at"`
}

type ProposedPlugin struct {
	PluginID        string                    `json:"plugin_id"`
	PublicKey       string                    `json:"public_key"`
	Title           string                    `json:"title"`
	Description     string                    `json:"description"`
	ServerEndpoint  string                    `json:"server_endpoint"`
	Category        PluginCategory            `json:"category"`
	SupportedChains []string                  `json:"supported_chains"`
	PricingModel    NullProposedPluginPricing `json:"pricing_model"`
	ContactEmail    string                    `json:"contact_email"`
	Notes           string                    `json:"notes"`
	Status          ProposedPluginStatus      `json:"status"`
	CreatedAt       pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz        `json:"updated_at"`
}

type ProposedPluginImage struct {
	ID                  pgtype.UUID        `json:"id"`
	PluginID            string             `json:"plugin_id"`
	ImageType           string             `json:"image_type"`
	S3Path              string             `json:"s3_path"`
	ImageOrder          int32              `json:"image_order"`
	UploadedByPublicKey string             `json:"uploaded_by_public_key"`
	Visible             bool               `json:"visible"`
	Deleted             bool               `json:"deleted"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ContentType         string             `json:"content_type"`
	Filename            string             `json:"filename"`
}

type Review struct {
	ID        pgtype.UUID        `json:"id"`
	PluginID  pgtype.Text        `json:"plugin_id"`
	PublicKey string             `json:"public_key"`
	Rating    int32              `json:"rating"`
	Comment   pgtype.Text        `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Tag struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type TxIndexer struct {
	ID            pgtype.UUID                `json:"id"`
	PluginID      string                     `json:"plugin_id"`
	TxHash        pgtype.Text                `json:"tx_hash"`
	ChainID       int32                      `json:"chain_id"`
	PolicyID      pgtype.UUID                `json:"policy_id"`
	TokenID       string                     `json:"token_id"`
	FromPublicKey string                     `json:"from_public_key"`
	ToPublicKey   string                     `json:"to_public_key"`
	ProposedTxHex string                     `json:"proposed_tx_hex"`
	Status        TxIndexerStatus            `json:"status"`
	StatusOnchain NullTxIndexerStatusOnchain `json:"status_onchain"`
	Lost          bool                       `json:"lost"`
	BroadcastedAt pgtype.Timestamp           `json:"broadcasted_at"`
	CreatedAt     pgtype.Timestamp           `json:"created_at"`
	UpdatedAt     pgtype.Timestamp           `json:"updated_at"`
	Amount        pgtype.Text                `json:"amount"`
	ErrorMessage  pgtype.Text                `json:"error_message"`
}

type VaultToken struct {
	ID         pgtype.UUID        `json:"id"`
	TokenID    string             `json:"token_id"`
	PublicKey  string             `json:"public_key"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	RevokedAt  pgtype.Timestamptz `json:"revoked_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}
