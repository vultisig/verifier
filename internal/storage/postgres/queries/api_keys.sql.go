// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireApiKeyLock = `-- name: AcquireApiKeyLock :exec
SELECT pg_advisory_xact_lock(hashtextextended($1::text, 0))
`

func (q *Queries) AcquireApiKeyLock(ctx context.Context, dollar_1 string) error {
	_, err := q.db.Exec(ctx, acquireApiKeyLock, dollar_1)
	return err
}

const countActiveApiKeys = `-- name: CountActiveApiKeys :one
SELECT COUNT(*) FROM plugin_apikey
WHERE plugin_id = $1
  AND status = 1
  AND (expires_at IS NULL OR expires_at > NOW())
`

func (q *Queries) CountActiveApiKeys(ctx context.Context, pluginID string) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveApiKeys, pluginID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPluginApiKey = `-- name: CreatePluginApiKey :one
INSERT INTO plugin_apikey (plugin_id, apikey, expires_at, status)
VALUES ($1, $2, $3, 1)
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type CreatePluginApiKeyParams struct {
	PluginID  string             `json:"plugin_id"`
	Apikey    string             `json:"apikey"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreatePluginApiKey(ctx context.Context, arg *CreatePluginApiKeyParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, createPluginApiKey, arg.PluginID, arg.Apikey, arg.ExpiresAt)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const expirePluginApiKey = `-- name: ExpirePluginApiKey :one
UPDATE plugin_apikey
SET expires_at = NOW()
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

func (q *Queries) ExpirePluginApiKey(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, expirePluginApiKey, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getPluginApiKeyByID = `-- name: GetPluginApiKeyByID :one
SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE id = $1
`

func (q *Queries) GetPluginApiKeyByID(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, getPluginApiKeyByID, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getPluginApiKeys = `-- name: GetPluginApiKeys :many

SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE plugin_id = $1
ORDER BY created_at DESC
`

// Plugin API Keys table queries
func (q *Queries) GetPluginApiKeys(ctx context.Context, pluginID string) ([]*PluginApikey, error) {
	rows, err := q.db.Query(ctx, getPluginApiKeys, pluginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PluginApikey{}
	for rows.Next() {
		var i PluginApikey
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.Apikey,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePluginApiKeyStatus = `-- name: UpdatePluginApiKeyStatus :one
UPDATE plugin_apikey
SET status = $2
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type UpdatePluginApiKeyStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status int32       `json:"status"`
}

func (q *Queries) UpdatePluginApiKeyStatus(ctx context.Context, arg *UpdatePluginApiKeyStatusParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, updatePluginApiKeyStatus, arg.ID, arg.Status)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}
