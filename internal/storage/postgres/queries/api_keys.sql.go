// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPluginApiKeyWithLimit = `-- name: CreatePluginApiKeyWithLimit :one
INSERT INTO plugin_apikey (plugin_id, apikey, expires_at, status)
SELECT $1, $2, $3, 1
WHERE (SELECT COUNT(*) FROM plugin_apikey
       WHERE plugin_id = $1 AND status = 1 AND (expires_at IS NULL OR expires_at > NOW())) < $4::int
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type CreatePluginApiKeyWithLimitParams struct {
	PluginID  PluginID           `json:"plugin_id"`
	Apikey    string             `json:"apikey"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	MaxKeys   int32              `json:"max_keys"`
}

func (q *Queries) CreatePluginApiKeyWithLimit(ctx context.Context, arg *CreatePluginApiKeyWithLimitParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, createPluginApiKeyWithLimit,
		arg.PluginID,
		arg.Apikey,
		arg.ExpiresAt,
		arg.MaxKeys,
	)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const expirePluginApiKey = `-- name: ExpirePluginApiKey :one
UPDATE plugin_apikey
SET expires_at = NOW()
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

func (q *Queries) ExpirePluginApiKey(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, expirePluginApiKey, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getPluginApiKeyByID = `-- name: GetPluginApiKeyByID :one
SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE id = $1
`

func (q *Queries) GetPluginApiKeyByID(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, getPluginApiKeyByID, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getPluginApiKeys = `-- name: GetPluginApiKeys :many

SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE plugin_id = $1
ORDER BY created_at DESC
`

// Plugin API Keys table queries
func (q *Queries) GetPluginApiKeys(ctx context.Context, pluginID PluginID) ([]*PluginApikey, error) {
	rows, err := q.db.Query(ctx, getPluginApiKeys, pluginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PluginApikey{}
	for rows.Next() {
		var i PluginApikey
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.Apikey,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePluginApiKeyStatus = `-- name: UpdatePluginApiKeyStatus :one
UPDATE plugin_apikey
SET status = $2
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type UpdatePluginApiKeyStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status int32       `json:"status"`
}

func (q *Queries) UpdatePluginApiKeyStatus(ctx context.Context, arg *UpdatePluginApiKeyStatusParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, updatePluginApiKeyStatus, arg.ID, arg.Status)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}
