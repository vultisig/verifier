// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: plugins.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPluginApiKey = `-- name: CreatePluginApiKey :one
INSERT INTO plugin_apikey (plugin_id, apikey, expires_at, status)
VALUES ($1, $2, $3, 1)
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type CreatePluginApiKeyParams struct {
	PluginID  PluginID           `json:"plugin_id"`
	Apikey    string             `json:"apikey"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreatePluginApiKey(ctx context.Context, arg *CreatePluginApiKeyParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, createPluginApiKey, arg.PluginID, arg.Apikey, arg.ExpiresAt)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const expirePluginApiKey = `-- name: ExpirePluginApiKey :one
UPDATE plugin_apikey
SET expires_at = NOW()
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

func (q *Queries) ExpirePluginApiKey(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, expirePluginApiKey, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getEarningsByPluginForOwner = `-- name: GetEarningsByPluginForOwner :many
SELECT
    f.plugin_id,
    COALESCE(SUM(f.amount), 0)::bigint as total
FROM fees f
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
GROUP BY f.plugin_id
`

type GetEarningsByPluginForOwnerRow struct {
	PluginID pgtype.Text `json:"plugin_id"`
	Total    int64       `json:"total"`
}

func (q *Queries) GetEarningsByPluginForOwner(ctx context.Context, publicKey string) ([]*GetEarningsByPluginForOwnerRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginForOwner, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginForOwnerRow{}
	for rows.Next() {
		var i GetEarningsByPluginForOwnerRow
		if err := rows.Scan(&i.PluginID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsByPluginOwner = `-- name: GetEarningsByPluginOwner :many
SELECT
    f.id,
    f.plugin_id,
    p.title as plugin_name,
    f.amount,
    'usdc' as asset,
    COALESCE(ppb.type::text, 'per-tx') as pricing_type,
    f.created_at,
    f.public_key as from_address,
    COALESCE(ti.tx_hash, '') as tx_hash,
    CASE
        WHEN ti.status_onchain = 'SUCCESS' THEN 'completed'
        WHEN ti.status_onchain = 'FAIL' THEN 'failed'
        ELSE 'pending'
    END as status
FROM fees f
JOIN plugins p ON f.plugin_id::plugin_id = p.id
LEFT JOIN plugin_policies pp ON f.policy_id = pp.id
LEFT JOIN plugin_policy_billing ppb ON pp.id = ppb.plugin_policy_id
LEFT JOIN tx_indexer ti ON f.policy_id = ti.policy_id
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
ORDER BY f.created_at DESC
`

type GetEarningsByPluginOwnerRow struct {
	ID          int64              `json:"id"`
	PluginID    pgtype.Text        `json:"plugin_id"`
	PluginName  string             `json:"plugin_name"`
	Amount      int64              `json:"amount"`
	Asset       string             `json:"asset"`
	PricingType interface{}        `json:"pricing_type"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FromAddress string             `json:"from_address"`
	TxHash      string             `json:"tx_hash"`
	Status      string             `json:"status"`
}

func (q *Queries) GetEarningsByPluginOwner(ctx context.Context, publicKey string) ([]*GetEarningsByPluginOwnerRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginOwner, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginOwnerRow{}
	for rows.Next() {
		var i GetEarningsByPluginOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.PluginName,
			&i.Amount,
			&i.Asset,
			&i.PricingType,
			&i.CreatedAt,
			&i.FromAddress,
			&i.TxHash,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsByPluginOwnerFiltered = `-- name: GetEarningsByPluginOwnerFiltered :many
SELECT
    f.id,
    f.plugin_id,
    p.title as plugin_name,
    f.amount,
    'usdc' as asset,
    COALESCE(ppb.type::text, 'per-tx') as pricing_type,
    f.created_at,
    f.public_key as from_address,
    COALESCE(ti.tx_hash, '') as tx_hash,
    CASE
        WHEN ti.status_onchain = 'SUCCESS' THEN 'completed'
        WHEN ti.status_onchain = 'FAIL' THEN 'failed'
        ELSE 'pending'
    END as status
FROM fees f
JOIN plugins p ON f.plugin_id::plugin_id = p.id
LEFT JOIN plugin_policies pp ON f.policy_id = pp.id
LEFT JOIN plugin_policy_billing ppb ON pp.id = ppb.plugin_policy_id
LEFT JOIN tx_indexer ti ON f.policy_id = ti.policy_id
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
AND (NULLIF($2, '')::text IS NULL OR f.plugin_id = $2)
AND ($3::timestamptz IS NULL OR f.created_at >= $3)
AND ($4::timestamptz IS NULL OR f.created_at <= $4)
ORDER BY f.created_at DESC
`

type GetEarningsByPluginOwnerFilteredParams struct {
	PublicKey string             `json:"public_key"`
	Column2   interface{}        `json:"column_2"`
	Column3   pgtype.Timestamptz `json:"column_3"`
	Column4   pgtype.Timestamptz `json:"column_4"`
}

type GetEarningsByPluginOwnerFilteredRow struct {
	ID          int64              `json:"id"`
	PluginID    pgtype.Text        `json:"plugin_id"`
	PluginName  string             `json:"plugin_name"`
	Amount      int64              `json:"amount"`
	Asset       string             `json:"asset"`
	PricingType interface{}        `json:"pricing_type"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FromAddress string             `json:"from_address"`
	TxHash      string             `json:"tx_hash"`
	Status      string             `json:"status"`
}

func (q *Queries) GetEarningsByPluginOwnerFiltered(ctx context.Context, arg *GetEarningsByPluginOwnerFilteredParams) ([]*GetEarningsByPluginOwnerFilteredRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginOwnerFiltered,
		arg.PublicKey,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginOwnerFilteredRow{}
	for rows.Next() {
		var i GetEarningsByPluginOwnerFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.PluginName,
			&i.Amount,
			&i.Asset,
			&i.PricingType,
			&i.CreatedAt,
			&i.FromAddress,
			&i.TxHash,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsSummaryByPluginOwner = `-- name: GetEarningsSummaryByPluginOwner :one
SELECT
    COALESCE(SUM(f.amount), 0)::bigint as total_earnings,
    COUNT(f.id)::bigint as total_transactions
FROM fees f
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
`

type GetEarningsSummaryByPluginOwnerRow struct {
	TotalEarnings     int64 `json:"total_earnings"`
	TotalTransactions int64 `json:"total_transactions"`
}

func (q *Queries) GetEarningsSummaryByPluginOwner(ctx context.Context, publicKey string) (*GetEarningsSummaryByPluginOwnerRow, error) {
	row := q.db.QueryRow(ctx, getEarningsSummaryByPluginOwner, publicKey)
	var i GetEarningsSummaryByPluginOwnerRow
	err := row.Scan(&i.TotalEarnings, &i.TotalTransactions)
	return &i, err
}

const getPluginApiKeyByID = `-- name: GetPluginApiKeyByID :one
SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE id = $1
`

func (q *Queries) GetPluginApiKeyByID(ctx context.Context, id pgtype.UUID) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, getPluginApiKeyByID, id)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}

const getPluginApiKeys = `-- name: GetPluginApiKeys :many
SELECT id, plugin_id, apikey, created_at, expires_at, status FROM plugin_apikey
WHERE plugin_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPluginApiKeys(ctx context.Context, pluginID PluginID) ([]*PluginApikey, error) {
	rows, err := q.db.Query(ctx, getPluginApiKeys, pluginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PluginApikey{}
	for rows.Next() {
		var i PluginApikey
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.Apikey,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluginByID = `-- name: GetPluginByID :one
SELECT id, title, description, server_endpoint, category, created_at, updated_at, logo_url, thumbnail_url, images, faqs, features, audited FROM plugins
WHERE id = $1
`

func (q *Queries) GetPluginByID(ctx context.Context, id PluginID) (*Plugin, error) {
	row := q.db.QueryRow(ctx, getPluginByID, id)
	var i Plugin
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LogoUrl,
		&i.ThumbnailUrl,
		&i.Images,
		&i.Faqs,
		&i.Features,
		&i.Audited,
	)
	return &i, err
}

const getPluginByIDAndOwner = `-- name: GetPluginByIDAndOwner :one
SELECT p.id, p.title, p.description, p.server_endpoint, p.category, p.created_at, p.updated_at, p.logo_url, p.thumbnail_url, p.images, p.faqs, p.features, p.audited FROM plugins p
JOIN plugin_owners po ON p.id::text = po.plugin_id::text
WHERE p.id = $1 AND po.public_key = $2 AND po.active = true
`

type GetPluginByIDAndOwnerParams struct {
	ID        PluginID `json:"id"`
	PublicKey string   `json:"public_key"`
}

func (q *Queries) GetPluginByIDAndOwner(ctx context.Context, arg *GetPluginByIDAndOwnerParams) (*Plugin, error) {
	row := q.db.QueryRow(ctx, getPluginByIDAndOwner, arg.ID, arg.PublicKey)
	var i Plugin
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LogoUrl,
		&i.ThumbnailUrl,
		&i.Images,
		&i.Faqs,
		&i.Features,
		&i.Audited,
	)
	return &i, err
}

const getPluginOwner = `-- name: GetPluginOwner :one
SELECT plugin_id, public_key, active, role, added_via, added_by_public_key, created_at, updated_at FROM plugin_owners
WHERE plugin_id = $1 AND public_key = $2 AND active = true
`

type GetPluginOwnerParams struct {
	PluginID  PluginID `json:"plugin_id"`
	PublicKey string   `json:"public_key"`
}

func (q *Queries) GetPluginOwner(ctx context.Context, arg *GetPluginOwnerParams) (*PluginOwner, error) {
	row := q.db.QueryRow(ctx, getPluginOwner, arg.PluginID, arg.PublicKey)
	var i PluginOwner
	err := row.Scan(
		&i.PluginID,
		&i.PublicKey,
		&i.Active,
		&i.Role,
		&i.AddedVia,
		&i.AddedByPublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPluginPricings = `-- name: GetPluginPricings :many
SELECT id, type, frequency, amount, asset, metric, plugin_id, created_at, updated_at FROM pricings
WHERE plugin_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPluginPricings(ctx context.Context, pluginID PluginID) ([]*Pricing, error) {
	rows, err := q.db.Query(ctx, getPluginPricings, pluginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Pricing{}
	for rows.Next() {
		var i Pricing
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Frequency,
			&i.Amount,
			&i.Asset,
			&i.Metric,
			&i.PluginID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPluginOwners = `-- name: ListPluginOwners :many
SELECT plugin_id, public_key, active, role, added_via, added_by_public_key, created_at, updated_at FROM plugin_owners
WHERE plugin_id = $1 AND active = true
ORDER BY created_at ASC
`

func (q *Queries) ListPluginOwners(ctx context.Context, pluginID PluginID) ([]*PluginOwner, error) {
	rows, err := q.db.Query(ctx, listPluginOwners, pluginID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PluginOwner{}
	for rows.Next() {
		var i PluginOwner
		if err := rows.Scan(
			&i.PluginID,
			&i.PublicKey,
			&i.Active,
			&i.Role,
			&i.AddedVia,
			&i.AddedByPublicKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlugins = `-- name: ListPlugins :many
SELECT id, title, description, server_endpoint, category, created_at, updated_at, logo_url, thumbnail_url, images, faqs, features, audited FROM plugins
ORDER BY updated_at DESC
`

func (q *Queries) ListPlugins(ctx context.Context) ([]*Plugin, error) {
	rows, err := q.db.Query(ctx, listPlugins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plugin{}
	for rows.Next() {
		var i Plugin
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ServerEndpoint,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LogoUrl,
			&i.ThumbnailUrl,
			&i.Images,
			&i.Faqs,
			&i.Features,
			&i.Audited,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPluginsByOwner = `-- name: ListPluginsByOwner :many
SELECT p.id, p.title, p.description, p.server_endpoint, p.category, p.created_at, p.updated_at, p.logo_url, p.thumbnail_url, p.images, p.faqs, p.features, p.audited FROM plugins p
JOIN plugin_owners po ON p.id::text = po.plugin_id::text
WHERE po.public_key = $1 AND po.active = true
ORDER BY p.updated_at DESC
`

func (q *Queries) ListPluginsByOwner(ctx context.Context, publicKey string) ([]*Plugin, error) {
	rows, err := q.db.Query(ctx, listPluginsByOwner, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plugin{}
	for rows.Next() {
		var i Plugin
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ServerEndpoint,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LogoUrl,
			&i.ThumbnailUrl,
			&i.Images,
			&i.Faqs,
			&i.Features,
			&i.Audited,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlugin = `-- name: UpdatePlugin :one
UPDATE plugins
SET
    title = $2,
    description = $3,
    server_endpoint = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, title, description, server_endpoint, category, created_at, updated_at, logo_url, thumbnail_url, images, faqs, features, audited
`

type UpdatePluginParams struct {
	ID             PluginID `json:"id"`
	Title          string   `json:"title"`
	Description    string   `json:"description"`
	ServerEndpoint string   `json:"server_endpoint"`
}

func (q *Queries) UpdatePlugin(ctx context.Context, arg *UpdatePluginParams) (*Plugin, error) {
	row := q.db.QueryRow(ctx, updatePlugin,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ServerEndpoint,
	)
	var i Plugin
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ServerEndpoint,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LogoUrl,
		&i.ThumbnailUrl,
		&i.Images,
		&i.Faqs,
		&i.Features,
		&i.Audited,
	)
	return &i, err
}

const updatePluginApiKeyStatus = `-- name: UpdatePluginApiKeyStatus :one
UPDATE plugin_apikey
SET status = $2
WHERE id = $1
RETURNING id, plugin_id, apikey, created_at, expires_at, status
`

type UpdatePluginApiKeyStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status int32       `json:"status"`
}

func (q *Queries) UpdatePluginApiKeyStatus(ctx context.Context, arg *UpdatePluginApiKeyStatusParams) (*PluginApikey, error) {
	row := q.db.QueryRow(ctx, updatePluginApiKeyStatus, arg.ID, arg.Status)
	var i PluginApikey
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Apikey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return &i, err
}
