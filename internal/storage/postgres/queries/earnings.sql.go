// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: earnings.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEarningsByPluginOwnerFiltered = `-- name: CountEarningsByPluginOwnerFiltered :one
SELECT COUNT(DISTINCT f.id)::bigint as total
FROM fees f
JOIN plugins p ON f.plugin_id = p.id::text
LEFT JOIN plugin_policies pp ON f.policy_id = pp.id
LEFT JOIN plugin_policy_billing ppb ON pp.id = ppb.plugin_policy_id
LEFT JOIN tx_indexer ti ON f.policy_id = ti.policy_id
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
AND (NULLIF($2, '')::text IS NULL OR f.plugin_id = $2)
AND ($3::timestamptz IS NULL OR f.created_at >= $3)
AND ($4::timestamptz IS NULL OR f.created_at <= $4)
`

type CountEarningsByPluginOwnerFilteredParams struct {
	PublicKey string             `json:"public_key"`
	Column2   interface{}        `json:"column_2"`
	Column3   pgtype.Timestamptz `json:"column_3"`
	Column4   pgtype.Timestamptz `json:"column_4"`
}

func (q *Queries) CountEarningsByPluginOwnerFiltered(ctx context.Context, arg *CountEarningsByPluginOwnerFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEarningsByPluginOwnerFiltered,
		arg.PublicKey,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getEarningsByPluginForOwner = `-- name: GetEarningsByPluginForOwner :many
SELECT
    f.plugin_id,
    COALESCE(SUM(f.amount), 0)::bigint as total
FROM fees f
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
GROUP BY f.plugin_id
`

type GetEarningsByPluginForOwnerRow struct {
	PluginID pgtype.Text `json:"plugin_id"`
	Total    int64       `json:"total"`
}

func (q *Queries) GetEarningsByPluginForOwner(ctx context.Context, publicKey string) ([]*GetEarningsByPluginForOwnerRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginForOwner, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginForOwnerRow{}
	for rows.Next() {
		var i GetEarningsByPluginForOwnerRow
		if err := rows.Scan(&i.PluginID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsByPluginOwner = `-- name: GetEarningsByPluginOwner :many

SELECT
    f.id,
    f.plugin_id,
    p.title as plugin_name,
    f.amount,
    'usdc' as asset,
    COALESCE(ppb.type::text, 'per-tx') as pricing_type,
    f.created_at,
    f.public_key as from_address,
    COALESCE(ti.tx_hash, '') as tx_hash,
    CASE
        WHEN ti.status_onchain = 'SUCCESS' THEN 'completed'
        WHEN ti.status_onchain = 'FAIL' THEN 'failed'
        ELSE 'pending'
    END as status
FROM fees f
JOIN plugins p ON f.plugin_id = p.id::text
LEFT JOIN plugin_policies pp ON f.policy_id = pp.id
LEFT JOIN plugin_policy_billing ppb ON pp.id = ppb.plugin_policy_id
LEFT JOIN tx_indexer ti ON f.policy_id = ti.policy_id
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
ORDER BY f.created_at DESC
`

type GetEarningsByPluginOwnerRow struct {
	ID          int64              `json:"id"`
	PluginID    pgtype.Text        `json:"plugin_id"`
	PluginName  string             `json:"plugin_name"`
	Amount      int64              `json:"amount"`
	Asset       string             `json:"asset"`
	PricingType interface{}        `json:"pricing_type"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FromAddress string             `json:"from_address"`
	TxHash      string             `json:"tx_hash"`
	Status      string             `json:"status"`
}

// Earnings/Fees table queries
func (q *Queries) GetEarningsByPluginOwner(ctx context.Context, publicKey string) ([]*GetEarningsByPluginOwnerRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginOwner, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginOwnerRow{}
	for rows.Next() {
		var i GetEarningsByPluginOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.PluginName,
			&i.Amount,
			&i.Asset,
			&i.PricingType,
			&i.CreatedAt,
			&i.FromAddress,
			&i.TxHash,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsByPluginOwnerFiltered = `-- name: GetEarningsByPluginOwnerFiltered :many
SELECT
    f.id,
    f.plugin_id,
    p.title as plugin_name,
    f.amount,
    'usdc' as asset,
    COALESCE(ppb.type::text, 'per-tx') as pricing_type,
    f.created_at,
    f.public_key as from_address,
    COALESCE(ti.tx_hash, '') as tx_hash,
    CASE
        WHEN ti.status_onchain = 'SUCCESS' THEN 'completed'
        WHEN ti.status_onchain = 'FAIL' THEN 'failed'
        ELSE 'pending'
    END as status
FROM fees f
JOIN plugins p ON f.plugin_id = p.id::text
LEFT JOIN plugin_policies pp ON f.policy_id = pp.id
LEFT JOIN plugin_policy_billing ppb ON pp.id = ppb.plugin_policy_id
LEFT JOIN tx_indexer ti ON f.policy_id = ti.policy_id
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
AND (NULLIF($2, '')::text IS NULL OR f.plugin_id = $2)
AND ($3::timestamptz IS NULL OR f.created_at >= $3)
AND ($4::timestamptz IS NULL OR f.created_at <= $4)
ORDER BY f.created_at DESC
LIMIT $5 OFFSET $6
`

type GetEarningsByPluginOwnerFilteredParams struct {
	PublicKey string             `json:"public_key"`
	Column2   interface{}        `json:"column_2"`
	Column3   pgtype.Timestamptz `json:"column_3"`
	Column4   pgtype.Timestamptz `json:"column_4"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetEarningsByPluginOwnerFilteredRow struct {
	ID          int64              `json:"id"`
	PluginID    pgtype.Text        `json:"plugin_id"`
	PluginName  string             `json:"plugin_name"`
	Amount      int64              `json:"amount"`
	Asset       string             `json:"asset"`
	PricingType interface{}        `json:"pricing_type"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FromAddress string             `json:"from_address"`
	TxHash      string             `json:"tx_hash"`
	Status      string             `json:"status"`
}

func (q *Queries) GetEarningsByPluginOwnerFiltered(ctx context.Context, arg *GetEarningsByPluginOwnerFilteredParams) ([]*GetEarningsByPluginOwnerFilteredRow, error) {
	rows, err := q.db.Query(ctx, getEarningsByPluginOwnerFiltered,
		arg.PublicKey,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEarningsByPluginOwnerFilteredRow{}
	for rows.Next() {
		var i GetEarningsByPluginOwnerFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.PluginID,
			&i.PluginName,
			&i.Amount,
			&i.Asset,
			&i.PricingType,
			&i.CreatedAt,
			&i.FromAddress,
			&i.TxHash,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEarningsSummaryByPluginOwner = `-- name: GetEarningsSummaryByPluginOwner :one
SELECT
    COALESCE(SUM(f.amount), 0)::bigint as total_earnings,
    COUNT(f.id)::bigint as total_transactions
FROM fees f
WHERE f.plugin_id IN (
    SELECT po.plugin_id::text FROM plugin_owners po WHERE po.public_key = $1 AND po.active = true
)
AND f.transaction_type = 'debit'
`

type GetEarningsSummaryByPluginOwnerRow struct {
	TotalEarnings     int64 `json:"total_earnings"`
	TotalTransactions int64 `json:"total_transactions"`
}

func (q *Queries) GetEarningsSummaryByPluginOwner(ctx context.Context, publicKey string) (*GetEarningsSummaryByPluginOwnerRow, error) {
	row := q.db.QueryRow(ctx, getEarningsSummaryByPluginOwner, publicKey)
	var i GetEarningsSummaryByPluginOwnerRow
	err := row.Scan(&i.TotalEarnings, &i.TotalTransactions)
	return &i, err
}
